@layout AdminShell

@page "/admin/manage/tags"
@inherits XaelithRestrictedPage

@inject IModalService Modals;
@inject IToastService Toasts;

<h1 class="admin-view-title">@Title</h1>

<div class="admin-inner-content">
    <EditForm Model="Context" OnSubmit="@SaveChanges">
        <DualValueEditor Context="Context"
                         FirstValueClass="tag"
                         FirstValueId="tag-name-edit-field"
                         FirstValuePlaceholder="Awaiting tag name..."
                         SecondValueClass="description"
                         SecondValueId="tag-description-edit-field"
                         SecondValuePlaceholder="Awaiting tag description..."
                         TableContainerClass="tag-editor"
                         ValueColumnClass="tag"
                         ValueColumnLabel="tags"
                         OnDeleteRequested="@DeleteTag"
                         OnAddRequested="@AddEmptyTag"
                         OnDiscardRequested="@DiscardChanges"/>
    </EditForm>
</div>


@code {
    [CascadingParameter]
    public UserContext UserContext { get; set; } = null!;

    protected override string Title => "tags";
    
    private DualValueEditContext Context { get; } = new();
    private List<DualValueEditContext.Entry> PreviousState { get; set; } = [];

    protected override void OnInitialized()
    {
        base.OnInitialized();

        foreach (var (name, description) in Configuration.Root!.Content.Tags)
        {
            Context.Entries.Add(new(name, description));
        }

        Context.Entries = Context.Entries
            .OrderBy(x => x.FirstValue)
            .ToList();

        PreviousState = new(Context.Entries);
    }

    private void SaveChanges(EditContext editContext)
    {
        var context = (DualValueEditContext)editContext.Model;

        if (context.Entries.Any(x => string.IsNullOrWhiteSpace(x.FirstValue)))
        {
            Toasts.Show(
                "Empty tag names are not allowed",
                ToastSeverity.Warning,
                3500
            );

            return;
        }

        try
        {
            var uniqueEntries = context.Entries.Select(x => x.FirstValue).Distinct();
            
            if (uniqueEntries.Count() != context.Entries.Count)
            {
                Toasts.Show(
                    "Tag names must be unique",
                    ToastSeverity.Error,
                    3500
                );

                return;
            }
            
            foreach (var tag in context.Entries)
            {
                if (string.IsNullOrWhiteSpace(tag.FirstValue))
                    continue;

                Configuration.Root!.Content.Tags[tag.FirstValue] = tag.SecondValue;
            }

            context.Entries = context.Entries
                .OrderBy(x => x.FirstValue)
                .ToList();

            Configuration.Save();
            PreviousState = new(context.Entries);
            
            Toasts.Show(
                "Tags updated",
                ToastSeverity.Success
            );
        }
        catch (Exception e)
        {
            Toasts.Show(
                $"Failed to update tags: {e.Message}",
                ToastSeverity.Error,
                3500
            );
        }
    }

    private void AddEmptyTag()
        => Context.Entries.Insert(0, new(string.Empty, string.Empty));

    private void DeleteTag(int index)
        => Context.Entries.RemoveAt(index);

    private async Task DiscardChanges()
    {
        await Modals.ShowAsync(
            new DialogModalData(
                "Discard changes?",
                "Confirm discarding any changes made to tags.<br/>" +
                "This action is irreversible.",
                "Proceed",
                "Abort",
                DialogModalSeverity.Warning,
                (result) =>
                {
                    if (result)
                        Context.Entries = [..PreviousState];
                }
            )
        );
    }
}